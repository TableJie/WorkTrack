using Dapper;
using Microsoft.Data.Sqlite;
using System.Windows;
using System.Windows.Controls;
using System.Data;

namespace WorkTrack
{
    public partial class OverTimeInput : Window
    {

        private const int MAX_TASK_PLANS = 8;
        private const double OVER_HOURS_FACTOR = 0.5;
        private readonly DateTime _taskDate;

        public OverTimeInput(DateTime taskDate)
        {
            InitializeComponent();
            _taskDate = taskDate;
            ip_TaskDate.SelectedDate = _taskDate;
        }


        private void ip_OverHours_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {

            if (ip_OverHours.SelectedItem == null)
            {
                pn_Task.Visibility = Visibility.Collapsed;
                return;
            }

            pn_Task.Visibility = Visibility.Visible;

            if (ip_OverHours.SelectedItem is ComboBoxItem selectedItem)
            {

                int selectedIndex = ip_OverHours.Items.IndexOf(selectedItem);  // ?? ComboBox ? index ??????

                for (int i = 0; i < pn_Plan.Children.Count; i++)
                {
                    if (i < selectedIndex + 1)  // ????? index ????? TextBox
                    {
                        ((TextBox)pn_Plan.Children[i]).Visibility = Visibility.Visible;
                    }
                    else
                    {
                        ((TextBox)pn_Plan.Children[i]).Visibility = Visibility.Collapsed;
                    }
                }
            }
        }


        private async void RefreshButton_Click(object sender, RoutedEventArgs e)
        {
            if (!ValidateInput())
            {
                MessageBox.Show("??????????????", "??", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            try
            {
                using (var connection = new SqliteConnection(App.ConnectionString))
                {
                    await connection.OpenAsync();

                    using (var transaction = connection.BeginTransaction())
                    {
                        var overHours = (ip_OverHours.SelectedIndex + 1) * OVER_HOURS_FACTOR;
                        var taskPlans = Enumerable.Range(1, MAX_TASK_PLANS)
                            .Select(i => (FindName($"ip_TaskPlan{i}") as TextBox)?.Visibility == Visibility.Visible
                                ? (FindName($"ip_TaskPlan{i}") as TextBox)?.Text
                                : null)
                            .ToArray();

                        var overTimeQuery = @"
                                            INSERT INTO OverTime (TaskDate, OverHours, TaskPlan1, TaskPlan2, TaskPlan3, TaskPlan4, TaskPlan5, TaskPlan6, TaskPlan7, TaskPlan8)
                                            VALUES (@TaskDate, @OverHours, @TaskPlan1, @TaskPlan2, @TaskPlan3, @TaskPlan4, @TaskPlan5, @TaskPlan6, @TaskPlan7, @TaskPlan8)
                                            ON CONFLICT(TaskDate) DO UPDATE SET
                                            OverHours = @OverHours,
                                            TaskPlan1 = @TaskPlan1, TaskPlan2 = @TaskPlan2, TaskPlan3 = @TaskPlan3, TaskPlan4 = @TaskPlan4,
                                            TaskPlan5 = @TaskPlan5, TaskPlan6 = @TaskPlan6, TaskPlan7 = @TaskPlan7, TaskPlan8 = @TaskPlan8";

                        await connection.ExecuteAsync(overTimeQuery, new
                        {
                            TaskDate = _taskDate.ToString("yyyy-MM-dd")
                            ,OverHours = overHours
                            ,TaskPlan1 = taskPlans[0]
                            ,TaskPlan2 = taskPlans[1]
                            ,TaskPlan3 = taskPlans[2]
                            ,TaskPlan4 = taskPlans[3]
                            ,TaskPlan5 = taskPlans[4]
                            ,TaskPlan6 = taskPlans[5]
                            ,TaskPlan7 = taskPlans[6]
                            ,TaskPlan8 = taskPlans[7]
                        }, transaction);

                        var updateTaskHeaderQuery = @"
                                        UPDATE TaskHeader 
                                        SET OverHours = @OverHours 
                                        WHERE date(TaskDate) = @TaskDate";

                        await connection.ExecuteAsync(updateTaskHeaderQuery, new
                        {
                            TaskDate = _taskDate.ToString("yyyy-MM-dd"),
                            OverHours = overHours
                        }, transaction);

                        transaction.Commit();
                    }

                    MessageBox.Show("????????", "??", MessageBoxButton.OK, MessageBoxImage.Information);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"????: {ex.Message}", "??", MessageBoxButton.OK, MessageBoxImage.Error);
            }

            this.Close();
        }

        private void CloseButton_Click(object sender, RoutedEventArgs e)
        {
            this.Close(); // ??????
        }

        private bool ValidateInput()
        {
            return Enumerable.Range(1, MAX_TASK_PLANS)
                .All(i => (FindName($"ip_TaskPlan{i}") as TextBox)?.Visibility != Visibility.Visible ||
                          !string.IsNullOrWhiteSpace((FindName($"ip_TaskPlan{i}") as TextBox)?.Text));
        }
    }



}

This file is: OverTimeInput.xaml.cs

using Dapper;
using Microsoft.Data.Sqlite;
using Serilog;
using System.Windows;
using System.Windows.Controls;

namespace WorkTrack
{
    /// <summary>
    /// TaskInput.xaml ?????
    /// </summary>
    public partial class TaskInput : Window
    {
        private readonly Task _taskBody;
        private readonly bool _isCopyMode;

        public enum TaskInitializationMode
        {
            Add,    // ??????
            Edit,   // ????????
            Copy    // ????????
        }

        public TaskInput(Task taskBody, TaskInitializationMode initializationMode)
        {
            InitializeComponent();
            _taskBody = taskBody;
            _isCopyMode = initializationMode == TaskInitializationMode.Copy;

            Loaded += MainWindow_Loaded;
            ip_TaskName.Focus();
        }

        private async void MainWindow_Loaded(object sender, RoutedEventArgs e)
        {
            await LoadOption();

            // ?????
            ip_TaskDate.SelectedDate = _taskBody.TaskDate != default ? _taskBody.TaskDate : DateTime.Today;
            ip_TaskName.Text = _taskBody.TaskName;
            ip_Describe.Text = _taskBody.Description;
            ip_DurationLevelName.SelectedValue = _taskBody.DurationLevelID != 0 ? _taskBody.DurationLevelID : ip_DurationLevelName.Items[2];
            ip_Duration.Text = _taskBody.Duration.ToString();
            ip_UnitName.SelectedValue = _taskBody.UnitID != 0 ? _taskBody.UnitID : ip_UnitName.Items[0];
            ip_ApplicationID.Text = _taskBody.ApplicationID?.ToString();

            // ??????????? TaskID ?????
            this.Title = _isCopyMode ? "Copy Task" : _taskBody.TaskID == 0 ? "Add Task" : "Change Task";
            ip_TaskID.Visibility = _taskBody.TaskID == 0 || _isCopyMode ? Visibility.Collapsed : Visibility.Visible;
            if (!_isCopyMode && _taskBody.TaskID != 0)
            {
                ip_TaskID.Text = _taskBody.TaskID.ToString();
            }
        }

        private async System.Threading.Tasks.Task LoadOption()
        {
            try
            {
                await using var connection = new SqliteConnection(App.ConnectionString);
                await connection.OpenAsync();

                // ?? UnitNames ??
                var unitNames = (await connection.QueryAsync<Unit>("SELECT UnitID, UnitName FROM Unit WHERE DeleteFlag = @DeleteFlag", new { DeleteFlag = false })).ToList();
                unitNames.Add(new Unit { UnitID = 0, UnitName = "-Add-" });
                ip_UnitName.ItemsSource = unitNames;
                ip_UnitName.SelectedIndex = 0;

                // ?? DurationLevels ??
                var durationLevelNames = (await connection.QueryAsync<DurationLevel>("SELECT DurationLevelID, DurationLevelName FROM DurationLevel")).ToList();
                ip_DurationLevelName.ItemsSource = durationLevelNames;
                ip_DurationLevelName.SelectedIndex = 2;
            }
            catch (Exception ex)
            {
                MessageBox.Show($"?????????: {ex.Message}", "??", MessageBoxButton.OK, MessageBoxImage.Error);
            }

        }


        private void ip_DurationLevelName_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (ip_DurationLevelName.SelectedIndex == 5) 
            {
                ip_Duration.Visibility = Visibility.Visible;
                ip_DurationLevelName.Width = 110;
                ip_Duration.Focus();
                ip_Duration.SelectAll();
            }
            else
            {
                ip_Duration.Visibility = Visibility.Collapsed;
                ip_DurationLevelName.Width = 180;
            }
        }
        private void ip_UnitName_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (ip_UnitName.SelectedItem != null && ip_UnitName.SelectedItem.ToString() == "-Add-")
            {
                UnitManagement unitManagementWindow = new UnitManagement();
                unitManagementWindow.Closed += UnitManagementWindow_Closed;
                unitManagementWindow.ShowDialog();
            }
        }
        private async void UnitManagementWindow_Closed(object sender, EventArgs e)
        {
            await LoadOption(); // ??????UnitName??
        }


        private async System.Threading.Tasks.Task RefreshTaskBodyAsync()
        {
            try
            {
                using var connection = new SqliteConnection(App.ConnectionString);
                await connection.OpenAsync();

                string taskDate = (ip_TaskDate.SelectedDate ?? DateTime.Today).ToString("yyyy-MM-dd");
                string taskID = ip_TaskID.Text;
                string taskName = ip_TaskName.Text;
                string description = ip_Describe.Text;
                int durationLevelID = (int)ip_DurationLevelName.SelectedValue;
                int? duration = string.IsNullOrEmpty(ip_Duration.Text) ? (int?)null : int.Parse(ip_Duration.Text);
                int selectedUnitID = (int)ip_UnitName.SelectedValue;
                string applicationID = ip_ApplicationID.Text;


                if (string.IsNullOrEmpty(taskID))
                {
                    var insertQuery = $$"""
                        INSERT INTO TaskBody (TaskDate, TaskName, DurationLevelID, Duration, Description, UnitID, ApplicationID)
                        VALUES (@TaskDate, @TaskName, @DurationLevelID, @Duration, @Description, @UnitID, @ApplicationID);
                    """;

                    await connection.ExecuteAsync(insertQuery, new
                    {
                        TaskDate = taskDate,
                        TaskName = taskName,
                        DurationLevelID = durationLevelID,
                        Duration = duration,
                        Description = description,
                        UnitID = selectedUnitID,
                        ApplicationID = applicationID,
                    });
                }
                else
                {
                    var updateQuery = $$"""
                        UPDATE TaskBody
                        SET TaskName = @TaskName, DurationLevelID = @DurationLevelID, Duration = @Duration, Description = @Description,
                            UnitID = @UnitID, ApplicationID = @ApplicationID
                        WHERE TaskID = @TaskID;
                    """;

                    await connection.ExecuteAsync(updateQuery, new
                    {
                        TaskName = taskName,
                        DurationLevelID = durationLevelID,
                        Duration = duration,
                        Description = description,
                        UnitID = selectedUnitID,
                        ApplicationID = applicationID,
                        TaskID = taskID
                    });
                }

                var insertOrUpdateTaskHeader = $$"""
                   

                    WITH CTE AS (
                        SELECT 
                            sum(CASE WHEN DurationLevelID != 0 THEN DurationLevelID END) as UsedPoints
                            ,sum(CASE WHEN DurationLevelID = 0 THEN Duration END) as CustomizedMins
                        FROM TaskBody
                        WHERE TaskDate = @TaskDate
                    )
                    UPDATE TaskHeader
                    SET
                        UsedPoints = coalesce(CTE.UsedPoints, 0)
                        ,CustomizedMins = coalesce(CTE.CustomizedMins, 0)
                    FROM CTE
                    WHERE TaskHeader.TaskDate = @TaskDate
                    ;

                    UPDATE TaskBody
                    SET Duration = CAST(durationLevelID * (SELECT BasicPoints FROM TaskHeader WHERE TaskDate = @TaskDate) AS INTEGER)
                    WHERE
                        durationLevelID != 0
                        and TaskDate = @TaskDate
                    ;
                """;

                await connection.ExecuteAsync(insertOrUpdateTaskHeader, new { TaskDate = taskDate });
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to update task body: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }

        }
        private async void RefreshButton_Click(object sender, RoutedEventArgs e)
        {
            try {
                if (string.IsNullOrWhiteSpace(ip_TaskName.Text))
                {
                    MessageBox.Show("Input TaskName", "??", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                if (!ip_TaskDate.SelectedDate.HasValue)
                {
                    MessageBox.Show("Input TaskDate", "??", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                await RefreshTaskBodyAsync();

            ip_TaskID.Clear();
            ip_TaskName.Clear();
            ip_Describe.Clear();
            ip_DurationLevelName.SelectedIndex = 2;
            ip_UnitName.SelectedIndex = 0;
            ip_ApplicationID.SelectedIndex = 0;

            }
            catch (Exception ex)
            {
                MessageBox.Show($"??????: {ex.Message}", "??", MessageBoxButton.OK, MessageBoxImage.Error);
                // ????? Serilog ????????
                Log.Error(ex, "?????????");
            }

        }


        private void CloseButton_Click(object sender, RoutedEventArgs e)
        {
            this.Close(); // ??????
        }

    }


}

This file is: TaskInput.xaml.cs

using Dapper;
using LiveCharts;
using LiveCharts.Wpf;
using Microsoft.Data.Sqlite;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Navigation;
using static WorkTrack.TaskInput;
using Serilog;
using System.Windows.Documents;

namespace WorkTrack
{
    public partial class MainWindow : Window
    {
        private TaskSearch _taskSearch;
        public DateTime TodayDate { get; set; }
        public ChartValues<double> TaskDurations { get; set; } = new ChartValues<double>();
        public SeriesCollection SeriesCollection { get; set; } = new SeriesCollection();

        public MainWindow()
        {
            InitializeComponent();
            LogConfiguration.Initialize(); // ???????

            Log.Information("MainWindow initialized.");

            _taskSearch = new TaskSearch();  // ??? TaskSearch
            DataContext = this;
            TodayDate = DateTime.Now;

            Log.Information("Navigating to Page0_Welcome.");
            MainFrame.NavigationService.Navigate(new Page0_Welcome());

            try
            {
                Log.Information("Initializing database.");
                DatabaseInitializer dbInitializer = new DatabaseInitializer();
                dbInitializer.Initialize();
                Log.Information("Database initialized successfully.");
            }
            catch (Exception ex)
            {
                Log.Error(ex, "Failed to initialize database.");
                MessageBox.Show($"Database initialization failed: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }

            _ = InitializeStackedColumnChart(DateTime.Today);
        }

        #region Cd1_Bt

        public async System.Threading.Tasks.Task InitializeStackedColumnChart(DateTime selectedDate)
        {
            SeriesCollection.Clear();
            var formattedDate = selectedDate.ToString("yyyy-MM-dd");

            try
            {
                Log.Information("Fetching tasks for {FormattedDate}", formattedDate);
                var tasks = await _taskSearch.GetTasks(selectedDate);
                Log.Information("Fetched {TaskCount} tasks.", tasks.Count());

                int taskCount = 0;
                int pointsCount = 0;

                var query = @"
            SELECT AvailableMins, OverHours 
            FROM TaskHeader 
            WHERE date(TaskDate) = @TaskDate";

                double availableMins = 0;
                double overHours = 0;

                using (var connection = new SqliteConnection(App.ConnectionString))
                {
                    await connection.OpenAsync();
                    var result = await connection.QueryFirstOrDefaultAsync<(double AvailableMins, double OverHours)>(
                        query,
                        new { TaskDate = formattedDate }
                    );

                    if (result != default)
                    {
                        (availableMins, overHours) = result;
                    }
                    else
                    {
                        Log.Warning("No data found in TaskHeader for date: {FormattedDate}", formattedDate);
                        availableMins = 480; // ???,??????
                        overHours = 0;
                    }
                }

                if (tasks.Any() || availableMins > 0)
                {
                    foreach (var task in tasks)
                    {
                        taskCount++;
                        pointsCount += task.DurationLevelID;

                        SeriesCollection.Add(new StackedRowSeries
                        {
                            Values = new ChartValues<double> { Math.Max(task.Duration, 1) },
                            StackMode = StackMode.Values,
                            DataLabels = true,
                            Fill = Brushes.Teal,
                            Stroke = Brushes.White,
                            StrokeThickness = 0.5,
                            MaxRowHeight = 20,
                            Title = task.TaskName
                        });
                    }

                    if (availableMins > 0)
                    {
                        SeriesCollection.Add(new StackedRowSeries
                        {
                            Values = new ChartValues<double> { availableMins },
                            StackMode = StackMode.Values,
                            DataLabels = true,
                            Fill = Brushes.Gray,
                            Stroke = Brushes.White,
                            StrokeThickness = 0.5,
                            MaxRowHeight = 20,
                            Title = "Empty",
                        });
                    }
                }
                else
                {
                    Log.Warning("No data available for {SelectedDate}", selectedDate);
                    SeriesCollection.Add(new StackedRowSeries
                    {
                        Values = new ChartValues<double> { 480 },
                        StackMode = StackMode.Values,
                        DataLabels = true,
                        Fill = Brushes.Gray,
                        Stroke = Brushes.White,
                        StrokeThickness = 0.5,
                        MaxRowHeight = 20,
                        Title = "No Data"
                    });
                }

                double avgpoint = taskCount > 0 ? (double)pointsCount / taskCount : 0;
                await Application.Current.Dispatcher.InvokeAsync(() =>
                {
                    Card_Label1.Inlines.Clear();
                    Card_Label1.Inlines.Add(new Run($"{taskCount} ") { FontSize = 15 });
                    Card_Label1.Inlines.Add(new Run($"({avgpoint:F2})") { FontSize = 10 });

                    Card_Label2.Text = overHours.ToString("F1");
                });

                Log.Information("Chart initialized with {SeriesCount} series", SeriesCollection.Count);
            }
            catch (Exception ex)
            {
                Log.Error(ex, "Failed to load task durations for {SelectedDate}. SeriesCollection count: {Count}", selectedDate, SeriesCollection.Count);
                MessageBox.Show($"Failed to load task durations: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private async Task<IEnumerable<T>> ExecuteQueryAsync<T>(string query, object parameters = null)
        {
            try
            {
                Log.Information("Executing query: {Query}", query);
                await using var connection = new SqliteConnection(App.ConnectionString);
                await connection.OpenAsync();
                var result = await connection.QueryAsync<T>(query, parameters);
                Log.Information("Query executed successfully.");
                return result;
            }
            catch (Exception ex)
            {
                Log.Error(ex, "Failed to execute query: {Query}", query);
                MessageBox.Show($"Failed to execute query: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                return Enumerable.Empty<T>();
            }
        }

        private void bt_OverTime_Click(object sender, RoutedEventArgs e)
        {
            MainFrame.NavigationService.Navigate(new TaskPage());
            DateTime selectedDate = DateTime.Today;
            OverTimeInput overTimeInputWindow = new OverTimeInput(selectedDate);

            // ???????
            overTimeInputWindow.Left = this.Width - this.Left; // ??????????????
            overTimeInputWindow.Top = this.Top + 100; // ??????????
            overTimeInputWindow.ShowDialog();
        }

        private void bt_CardAddTask_Click(object sender, RoutedEventArgs e)
        {
            MainFrame.NavigationService.Navigate(new TaskPage());

            var newTask = new Task { TaskDate = DateTime.Today };
            TaskInput TaskInputWindow = new TaskInput(newTask, TaskInitializationMode.Add);
            TaskInputWindow.Left = this.Width - this.Left ; // ??????????????
            TaskInputWindow.Top = this.Top + 100; // ??????????
            TaskInputWindow.ShowDialog();
        }

        private void bt_TaskCheck_Click(object sender, RoutedEventArgs e)
        {
            MainFrame.NavigationService.Navigate(new TaskPage());
        }

        #endregion
    }
}

This file is: MainWindow.xaml.cs

Based on the above files, solve my requirements. Please answer in Traditional Chinese, prioritizing solutions that reduce system load, with maintainability as secondary. Responses should be clear, concise, and to the point. Since there are many different files, please first provide the file names and present the solutions in a before-and-after comparison format. For both the before and after content, only show the modified sections, no need to display everything. My requirement is:
