<Page x:Class="WorkTrack.TaskPage"
      xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
      xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
      xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
      xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
      xmlns:local="clr-namespace:WorkTrack"
      xmlns:materialDesign="http://materialdesigninxaml.net/winfx/xaml/themes"
      mc:Ignorable="d" 
      d:DesignHeight="450" d:DesignWidth="800"
      FontFamily="TimeNewsRoman"
      Title="Task">

    <Page.DataContext>
        <local:TaskViewModel xmlns:local="clr-namespace:WorkTrack"/>
    </Page.DataContext>

    <Grid HorizontalAlignment="Stretch">
        <Border Style="{StaticResource CardStyle}" Background="#F3F3F3">
            <Grid>
                <Grid.RowDefinitions>
                    <RowDefinition Height="40" />
                    <RowDefinition Height="*" />
                </Grid.RowDefinitions>

                <Grid>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>
                    <TextBlock Text="TaskList" Grid.Column="0"
                                HorizontalAlignment="Left"
                                VerticalAlignment="Center"
                                FontSize="18"
                                FontWeight="Bold"
                                Margin="5,0,0,0"
                                />
                    <StackPanel Orientation="Horizontal" Grid.Column="1" VerticalAlignment="Center" HorizontalAlignment="Right">
                        <DatePicker SelectedDate="{Binding SelectedDate, Mode=TwoWay}"
                                    Style="{StaticResource MaterialDesignFloatingHintDatePicker}"
                                    Width="90"
                                    Height="30"
                                    Margin="5,-10,5,0"
                                    VerticalAlignment="Center"
                                    materialDesign:HintAssist.Hint="TaskDate"
                                    materialDesign:HintAssist.FloatingOffset="0,-12"
                                    FirstDayOfWeek="Monday"
                                    SelectedDateFormat="Short"
                        />
                        <Button Command="{Binding AddTaskCommand}" Width="30" Padding="-5,0" Margin="0" Style="{StaticResource MaterialDesignFlatButton}">
                            <materialDesign:PackIcon Kind="ClipboardPlusOutline" 
                                                     Width="20" 
                                                     Height="20" 
                                                     Foreground="#008080" 
                                                     HorizontalAlignment="Center" 
                                                     VerticalAlignment="Center"/>
                        </Button>
                    </StackPanel>
                </Grid>

                <DataGrid ItemsSource="{Binding TaskBodyCollection}" Grid.Row="1"
                            AutoGenerateColumns="False"
                            CanUserAddRows="False"
                            CanUserDeleteRows="False"
                            IsReadOnly="True"
                            SelectionUnit="FullRow"
                            BorderThickness="0"
                            Background="White"
                            Margin="5"
                            ColumnHeaderHeight="40"
                            RowHeight="35"
                            Style="{StaticResource MaterialDesignDataGrid}">
                    <DataGrid.Columns>
                        <DataGridTextColumn Header="TaskName" Binding="{Binding TaskName}" Width="120" SortMemberPath="TaskName"/>
                        <DataGridTextColumn Header="UnitName" Binding="{Binding UnitName}" Width="*" SortMemberPath="UnitName"/>
                        <DataGridTextColumn Header="Duration" Binding="{Binding Duration}" Width="*" SortMemberPath="Duration" />
                        <DataGridTextColumn Header="Description" Binding="{Binding Description}" Width="*" SortMemberPath="Description"/>
                        <DataGridTemplateColumn Header="Action" Width="*" >
                            <DataGridTemplateColumn.CellTemplate>
                                <DataTemplate>
                                    <StackPanel Orientation="Horizontal" HorizontalAlignment="Left" Margin="-5">
                                        <Button x:Name="bt_TaskEdit" Command="{Binding DataContext.EditTaskCommand, RelativeSource={RelativeSource AncestorType=Page}}"
                                                CommandParameter="{Binding}" Width="30" Height="30" Padding="-5,0" Margin="0" HorizontalAlignment="Center" VerticalAlignment="Center"  Style="{StaticResource MaterialDesignFlatButton}" >
                                            <materialDesign:PackIcon Kind="ClipboardEditOutline" 
                                                             Width="20" 
                                                             Height="20" 
                                                             Foreground="Gray" 
                                                             HorizontalAlignment="Center" 
                                                             VerticalAlignment="Center"
                                                             ToolTip="Edit"/>
                                        </Button>
                                        <Button x:Name="bt_TaskCopy" Command="{Binding DataContext.CopyTaskCommand, RelativeSource={RelativeSource AncestorType=Page}}"
                                                CommandParameter="{Binding}" Width="30" Height="30" Padding="-5,0" Margin="0" HorizontalAlignment="Center" VerticalAlignment="Center"  Style="{StaticResource MaterialDesignFlatButton}" >
                                            <materialDesign:PackIcon Kind="ClipboardMultipleOutline" 
                                                             Width="20" 
                                                             Height="20" 
                                                             Foreground="Gray"
                                                             HorizontalAlignment="Center" 
                                                             VerticalAlignment="Center"
                                                             ToolTip="Copy"/>
                                        </Button>
                                        <ToggleButton Margin="5,0,0,0" Width="20" Height="20" Background="Transparent" Style="{StaticResource MaterialDesignActionToggleButton}" 
                                                      IsChecked="{Binding DeleteFlag}" 
                                                      Command="{Binding DataContext.ToggleTaskDeleteCommand, RelativeSource={RelativeSource AncestorType=Page}}"
                                                      CommandParameter="{Binding}">
                                            <materialDesign:ToggleButtonAssist.OnContent>
                                                <materialDesign:PackIcon Kind="ClipboardRemoveOutline" Width="20" Height="20" Foreground="{StaticResource ComplementaryBrush}" ToolTip="Delete"/>
                                            </materialDesign:ToggleButtonAssist.OnContent>
                                            <ToggleButton.Content>
                                                <materialDesign:PackIcon Kind="ClipboardPulseOutline" Width="20" Height="20" Foreground="{StaticResource PrimaryBrush}" ToolTip="Alive"/>
                                            </ToggleButton.Content>
                                        </ToggleButton>
                                    </StackPanel>
                                </DataTemplate>
                            </DataGridTemplateColumn.CellTemplate>
                        </DataGridTemplateColumn>
                    </DataGrid.Columns>
                </DataGrid>
            </Grid>
        </Border>
    </Grid>
</Page>

This file is: TaskPage.xaml

using Microsoft.Data.Sqlite;
using System;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using Dapper;
using static WorkTrack.InputTask;

namespace WorkTrack
{
    /// <summary>
    /// Page1.xaml ?????
    /// </summary>

    public partial class TaskPage : Page
    {
        private bool isDataLoading = false;

        public TaskPage()
        {
            InitializeComponent();
            LoadDataAndInitialize();
        }


        private async void LoadDataAndInitialize()
        {
            isDataLoading = true; // ?????

            ip_TaskDate.SelectedDate = DateTime.Today; // ????
            await DefaultSearch_TaskBody(); // ??????????

            isDataLoading = false; // ?????
        }

        public async System.Threading.Tasks.Task DefaultSearch_TaskBody()
        {
            isDataLoading = true;

            try
            {

                var taskSearch = new TaskSearch();
                var taskBodyData = await taskSearch.GetTasks(selectedDate.Date);

                dt_TaskBody.ItemsSource = taskBodyData;

            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to load TaskBody: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                isDataLoading = false;
            }
        }

        private void ActionButton_Click(object sender, RoutedEventArgs e)
        {
            if (sender is not Button button) return;

            TaskInitializationMode mode = button.Tag switch
            {
                "Add" => TaskInitializationMode.Add,
                "Edit" => TaskInitializationMode.Edit,
                "Copy" => TaskInitializationMode.Copy,
                _ => throw new ArgumentOutOfRangeException()
            };

            Task task = mode == TaskInitializationMode.Add
                ? new Task { TaskDate = ip_TaskDate.SelectedDate ?? DateTime.Today }
                : button.DataContext as Task ?? new Task { TaskDate = DateTime.Today };

            if (mode == TaskInitializationMode.Add && task.TaskDate == DateTime.MinValue)
            {
                MessageBox.Show("Please Select Date!", "Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            var inputTaskWindow = new InputTask(task, mode)
            {
                Left = Application.Current.MainWindow.Left + Application.Current.MainWindow.Width, // ??????????????
                Top = Application.Current.MainWindow.Top + 100 // ?????????????? 100
            };

            inputTaskWindow.ShowDialog();

        }

        private async void ip_TaskDate_SelectedDateChanged(object? sender, SelectionChangedEventArgs e)
        {
            await DefaultSearch_TaskBody();

            if (Application.Current.MainWindow is MainWindow mainWindow)
            {
                var selectedDate = ip_TaskDate.SelectedDate ?? DateTime.Today;

                mainWindow.ChartDate.Text = selectedDate.ToString("yyyy-MM-dd");
                await mainWindow.InitializeStackedColumnChart(selectedDate);
            }
        }

        private async void ToggleButton_CheckedOrUnchecked(object sender, RoutedEventArgs e)
        {

            if (isDataLoading) return; // ??????

            if (sender is ToggleButton toggleButton && toggleButton.DataContext is Task task)
            {
                bool deleteFlag = toggleButton.IsChecked == false;
                task.DeleteFlag = deleteFlag;
                    
                try
                {
                    await UpdateDeleteFlagInDatabase(task.TaskID, deleteFlag);

                    // ?????????????
                    string message = !deleteFlag ? "???? Task" : "???? Task";
                    MessageBox.Show(message, "????", MessageBoxButton.OK, MessageBoxImage.Information);
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"?????????: {ex.Message}", "??", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }

        private async System.Threading.Tasks.Task UpdateDeleteFlagInDatabase(int taskId, bool deleteFlag)
        {

            bool InputDeleteFlag = !deleteFlag;

            try
            {
                using var connection = new SqliteConnection(App.ConnectionString);
                await connection.OpenAsync();

                string query = "UPDATE TaskBody SET DeleteFlag = @DeleteFlag WHERE TaskID = @TaskID";
                await connection.ExecuteAsync(query, new { DeleteFlag = InputDeleteFlag, TaskID = taskId });
            }
            catch (Exception ex)
            {
                MessageBox.Show($"?????????: {ex.Message}", "??", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }



    }

}

This file is: TaskPage.xaml.cs

using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using Dapper;
using Microsoft.Data.Sqlite;
using static WorkTrack.InputTask;

namespace WorkTrack
{
    public class TaskViewModel : INotifyPropertyChanged
    {
        // Properties
        private DateTime? _selectedDate;
        public DateTime? SelectedDate
        {
            get => _selectedDate;
            set
            {
                if (_selectedDate != value)
                {
                    _selectedDate = value;
                    OnPropertyChanged(nameof(SelectedDate));
                    LoadTasksCommand.Execute(null);
                }
            }
        }

        private ObservableCollection<Task> _taskBodyCollection;
        public ObservableCollection<Task> TaskBodyCollection
        {
            get => _taskBodyCollection;
            set
            {
                _taskBodyCollection = value;
                OnPropertyChanged(nameof(TaskBodyCollection));
            }
        }

        // Commands
        public ICommand LoadTasksCommand { get; }
        public ICommand AddTaskCommand { get; }
        public ICommand EditTaskCommand { get; }
        public ICommand CopyTaskCommand { get; }
        public ICommand ToggleTaskDeleteCommand { get; }

        public TaskViewModel()
        {
            LoadTasksCommand = new AsyncRelayCommand(DefaultSearch_TaskBody);
            AddTaskCommand = new RelayCommand(AddTask);
            EditTaskCommand = new RelayCommand<Task>(EditTask);
            CopyTaskCommand = new RelayCommand<Task>(CopyTask);
            ToggleTaskDeleteCommand = new RelayCommand<Task>(ToggleTaskDelete);
            SelectedDate = DateTime.Today;
        }

        private async System.Threading.Tasks.Task DefaultSearch_TaskBody()
        {
            try
            {
                using var connection = new SqliteConnection(App.ConnectionString);
                await connection.OpenAsync();

                var taskSearch = new TaskSearch();
                var taskBodyData = await taskSearch.GetTasks(SelectedDate.Value.Date);
                TaskBodyCollection = new ObservableCollection<Task>(taskBodyData);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to load TaskBody: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void AddTask()
        {
            var inputTaskWindow = new InputTask(new Task { TaskDate = SelectedDate ?? DateTime.Today }, TaskInitializationMode.Add);
            inputTaskWindow.ShowDialog();
        }

        private void EditTask(Task task)
        {
            var inputTaskWindow = new InputTask(task, TaskInitializationMode.Edit);
            inputTaskWindow.ShowDialog();
        }

        private void CopyTask(Task task)
        {
            var copyTask = new Task
            {
                TaskName = task.TaskName,
                Description = task.Description,
                DurationLevelID = task.DurationLevelID,
                Duration = task.Duration,
                UnitID = task.UnitID,
                ApplicationID = task.ApplicationID,
                TaskDate = task.TaskDate
            };
            var inputTaskWindow = new InputTask(copyTask, TaskInitializationMode.Copy);
            inputTaskWindow.ShowDialog();
        }

        private async void ToggleTaskDelete(Task task)
        {
            task.DeleteFlag = !task.DeleteFlag;
            try
            {
                using var connection = new SqliteConnection(App.ConnectionString);
                await connection.OpenAsync();

                string query = "UPDATE TaskBody SET DeleteFlag = @DeleteFlag WHERE TaskID = @TaskID";
                await connection.ExecuteAsync(query, new { task.DeleteFlag, task.TaskID });
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Failed to update task: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        // INotifyPropertyChanged implementation
        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged(string propertyName) =>
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}

This file is: TaskViewModel.cs

using System;
using System.Threading.Tasks;
using System.Windows.Input;
using Serilog;
using System.Runtime.ExceptionServices;

namespace WorkTrack
{
    public class AsyncRelayCommand : BaseRelayCommand
    {
        private readonly Func<System.Threading.Tasks.Task> _execute;
        private readonly Func<bool>? _canExecute;
        private bool _isExecuting;

        public AsyncRelayCommand(Func<System.Threading.Tasks.Task> execute, Func<bool>? canExecute = null, ILogger? logger = null)
            : base(logger ?? Log.Logger)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        public override bool CanExecute(object? parameter)
        {
            bool result = !_isExecuting && (_canExecute == null || _canExecute());
            _logger.Information("CanExecute called: result={Result}, isExecuting={IsExecuting}", result, _isExecuting);
            return result;
        }

        public override async void Execute(object? parameter)
        {
            if (!CanExecute(parameter))
            {
                _logger.Warning("Execute called but command cannot be executed.");
                return;
            }

            _isExecuting = true;
            RaiseCanExecuteChanged();

            try
            {
                _logger.Information("Executing async command.");
                await _execute();
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Error occurred while executing async command.");
                ExceptionDispatchInfo.Capture(ex).Throw();  // ???????????????
            }
            finally
            {
                _isExecuting = false;
                RaiseCanExecuteChanged();
            }
        }

        public void RaiseCanExecuteChanged()
        {
            _logger.Debug("Raising CanExecuteChanged.");
            CommandManager.InvalidateRequerySuggested();
        }
    }
}

This file is: AsyncRelayCommand.cs

using System;
using System.Runtime.ExceptionServices;
using System.Windows.Input;
using Serilog;

namespace WorkTrack
{
    public abstract class BaseRelayCommand : ICommand
    {
        protected readonly ILogger _logger;

        protected BaseRelayCommand(ILogger logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public event EventHandler? CanExecuteChanged
        {
            add
            {
                CommandManager.RequerySuggested += value;
                _logger.Debug("CanExecuteChanged event subscribed");
            }
            remove
            {
                CommandManager.RequerySuggested -= value;
                _logger.Debug("CanExecuteChanged event unsubscribed");
            }
        }

        public abstract bool CanExecute(object? parameter);
        public abstract void Execute(object? parameter);
    }

    public class RelayCommand : BaseRelayCommand
    {
        private readonly Action _execute;
        private readonly Func<bool>? _canExecute;

        public RelayCommand(Action execute, Func<bool>? canExecute = null, ILogger? logger = null)
            : base(logger ?? Log.Logger)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        public override bool CanExecute(object? parameter)
        {
            bool result = _canExecute == null || _canExecute();
            _logger.Information("CanExecute called: result={Result}", result);
            return result;
        }

        public override void Execute(object? parameter)
        {
            try
            {
                _logger.Information("Executing command with no parameter");
                _execute();
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Error occurred while executing command with no parameter");
                ExceptionDispatchInfo.Capture(ex).Throw(); // ?? ExceptionDispatchInfo ??????
            }
        }
    }

    public class RelayCommand<T> : BaseRelayCommand
    {
        private readonly Action<T> _execute;
        private readonly Func<T, bool>? _canExecute;

        public RelayCommand(Action<T> execute, Func<T, bool>? canExecute = null, ILogger? logger = null)
            : base(logger ?? Log.Logger)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        public override bool CanExecute(object? parameter)
        {
            if (parameter == null && typeof(T).IsValueType)
            {
                _logger.Warning("CanExecute called with null parameter for value type {Type}", typeof(T).Name);
                return false;
            }

            bool result = _canExecute == null || _canExecute((T)parameter!);
            _logger.Information("CanExecute called: result={Result}, parameter={Parameter}", result, parameter);
            return result;
        }

        public override void Execute(object? parameter)
        {
            try
            {
                if (parameter == null && typeof(T).IsValueType)
                {
                    _logger.Error("Attempted to execute command with null parameter for value type {Type}", typeof(T).Name);
                    throw new InvalidOperationException($"The command parameter cannot be null because the expected type is a value type '{typeof(T).Name}'.");
                }

                _logger.Information("Executing command with parameter of type {Type}: {Parameter}", typeof(T).Name, parameter);
                _execute((T)parameter!);
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Error occurred while executing command with parameter of type {Type}", typeof(T).Name);
                ExceptionDispatchInfo.Capture(ex).Throw(); // ?? ExceptionDispatchInfo ??????
            }
        }
    }
}

This file is: RelayCommand.cs

Based on the above files, solve my requirements. Please answer in Traditional Chinese, prioritizing solutions that reduce system load, with maintainability as secondary. Responses should be clear, concise, and to the point. Since there are many different files, please first provide the file names and present the solutions in a before-and-after comparison format. For both the before and after content, only show the modified sections, no need to display everything. My requirement is:
